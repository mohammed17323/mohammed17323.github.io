<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fcc96e6835929d8eedf6a2029250747eaa9501e86cd8d0eba71ea9f8e8920b60741ec5f597ca9a55580e6151ae4436b3c9789843ecbb4606538dbfa772a625601453835f088d1114321c8c7076e765c6554f819a0363f160986056463effe5b2c9b4006de25c8aa14d18bda0080c9b8d376740eabc93c4626eadf95400f82138eb94272a036762e3d6638578307cb7a66b24dcf67932630d861cd3947b31f11f636286622b9429107306c6e2ec0ea669f08906c23c926c74c23246f806182e56ae7631c47563b7b3f1ac21951803683f55867f56ae3721e57c94945b6506b301db1eef6324192d84decb4fbd8b028993a287203e148e9ee2819bb9be5a15188d4c9ec0a470bf303cdd35af9fa501056d92d368d6347ce55cc2bb1d726bac3c47959c42090484020c920406ba29a83a042749499762bc8d4a76211266ffecdc900581f9fefbfd64faabaecd4ebf57d87c08a5a6af0e9a4a830e1ee60650ef7d3ca9ed3299025fb0ec55c50fecaab250dbfc80510e7eabe56a8ae343e3a613346d026bf0120a171f5d326c3a05f21bb86f19977aed14582e20bbb60df0d28b909f62c4a4821a7158c6b2af7b86b68910c57622d8750e2524be0af7c51cffe9fbbc6fa3d9f20c9a11ad3493b0fd29759f9e43dd1343401a3940d731f2526c3bd124214bcf00ac6f2be01265998c26b4c7c664dae71ba1c7f215e192856a3a7ac86a181acfc6d16fae8fa683b12454f94a1eec9bf68fcf0e2017b27469da8deca2ad9ceaa332eebf5d43ee64c2175c5bd2abefeebb12229a794e19690f5df28808b06f785a9f49c8dd1c1172b48ea7af379851cfe4d71429d350ae692c9bdcac39507b94282cf35adbd1cb5f32ef5d69a6f118e70c2e7601cbe868cad3ed88be7554654d1fc7446a343e62b6d8d00c2a0ffb84bea25a70b9e403b533673fc28dcf277df4173d2a382aa05fa25f721c73e294d66f48ed9c0382b45aa451a5ca31f8e07ddc81fcb76f0b19659e048325625697392de21dae0f8220da093eabcf0f9c1d767bdcec93982997a62abe92fbdf6758593eaf2d2fa693b7aca85b1d487021d1332c0b704792c1f6631c37dd43745e654a9324413533472a3df98426265c06e3db35e01b608fdb890d690079db808cf4f3980a4b6aff1d54a808e7b3b771e666e8fd4d33e235cf2e187875b57a16500f29b2dc76a21cd1248e19c3ff0866b49a7d30c5dead6d93f3f66fbde793f752ac8f192baa4c0dccbdcf7d9998c78aec05a513d150e9865bbbdbbe588bce85e30dff6174c34db60d31060760fad72f5cdeda1ccdf67c258d2df70c84b68340b18e883177401cd5c93363790c0ee157c45639cda07908665239dba1d324a2114a480bfecd2d62fe1e5b94a6991b61e255afad4bcf22a531f8536258ff6528e9e7b3d156e4ccc396f5f8b723c44ca372aa2b46bc9de85b8c9a3fa38f4cb02b1e696c5e58089fd094c6b7518c9db3d11c8458c14bfe03d605b28dc8f8a20cae1dd9850e721527f0df8be03feb049148e2439829fa71cf1d85d6acdb3a811c2fc962cbcbc008f8e7e9a2e6cd8d62bf2c10fcb51215796740a0cd302be885ec3ec0fac647f5071299e3e3a593260d7fef642baf78f8577415442134e4b54af6de223d9108499b779c3db800884fad4233119bd76ff6e2c4300e0af92b0943aa607a7edc345f661c1373380e5cdbdc95e88f788f6df58c5f604258bc847c82b02f5abb776a2cc456df8a0f962dabbdb8f389284373cec78208e9e69cea533bb94c51fff859ed46880a9ec0f48a40cf04d6bc105a9ed23224a7577ea9d7579873db66e4562ed7b1c45b9ed1ce7a53826c0e1ecce08dbccaa514d1221f95241544954b9f0aebcb4911723268b2778547c06b564bfc0b3a7da55e717d04275507848ab92146829d01ad9f04085281ce99af89da5d576fc69fd333fa7eaea5b06eca716d25f018ea1a1c53da41c5b1a38f04ea6cb3d60e42265b1c0f5036b2b79c401a31ba3a5f56c2b913a1df83a6fc308d13c0027436ac6629bc9162042f81a32e1004433fed34459b1f20fef511dc95ef47e92cef6b909fbe607eb876e0ff1aae0bb2c104b009caa4da1b3d56b3c7bf4871c3eddadb2d196b11fe7ae55e0dff489046e29020a8201425f394af92e26a7d983313566e8f5e39fc26f75708b30d74cd18d969a8ba70a0653ea312245a415458692aa0529db6734c6b627b13a9ee3d50eff930bb110a8bd15163b49f6dcf4b9909c832b4730f221229707002a52797c1cccb89f66f6afcd6982e62af691ff5a4c9afc29508b28bf90f25fec8a1b98a5586a7d068856bc355c06b0e663736a58ed1debd8b0728d88d08265b75724b0e6bba3882fd9efe1c0a7efd982461cb60271650527b009427fe4c86cba4e16f45b293b6a05e0426fc547aead9b1a4e2674dec621ffd2b555b8ece1f5f736b7a71c594424a627de04e97e4b9ae92c674d6ebe8c5d137e1470f1671920f5d8c708255a459e75fb805bf30366c16160f1d3a051eef91dca0d0ae92c94b089cfc28d0b522d598bc5134bc1efdf6eb7702a0c6cdc865c6346377b63ddb1b18dd7d37d8172548b13bde6e31960af88e355d888ade53f01d23c60af8cddbd0f47efae8a8ef6827ebcbe8f7a39473e66a01d536f68753e8f48cac96760e5f1c1598fe651b7cce82284e07ef4d46b3295fe1b919ad8fcf3bb46a5b467419f76800ab51ef1631aa3ad82c27dc10b7d0013cd9d6d9823b90ecd2a2376c1c6be89058b19acd3e144726530ce0556bd8f71c4b86738ceb365b6615c17716173c4daa6c8e20a322465e13e8b40ef993b395637a9f9ad9acbea99be909af3d0c434a88aab4115187d95b858b3c43a248f7c136f262c10254fc588f41a4412543bd17a4a2c27583e806a7ea88175e7b1268515574f6013b0e9c2248c2e56a789d83240cc7d67f3a538f41b1110fdca86592786c8cd3661d18780165decc19e78b38578a43155a2e26e7a6ed64bdf68d5c7b07d6a73c8cb0927f3527a07ab987a42878ae11e8357532931ab45a35c72b60a290dfad299f0b3884c7dfd926e99bdd30eac3a6a9be800fdef6b024e0e49c97a0919d43af5f7a75f1efdc5ebe7d7b812ba42e885666123c2f4574563589e4d3c3d79dfd0833bfa63e8a4e08d3772fe2fdbb7d5f785594e0df4624105b8d0e2a0eb6fa357cbceaf960f8da8f5397abc86e184f614343b21e4b4f801da165d834f32a9fc4865613b211d7700b923cb753fc1d4d96554182df830528575d7edc31d2f60a18be50c576714d55103f4e1ffced81c92dbe698aa3c47b7dd741d429833a62c45b3cf58f156371d3681ba1bc63450b364fc3603644765e170ecbe4d761045eb056ef2bc2d602121e324a2f53a147a3bbeef84e19d3b43d85286e9a7a938895a9e48c76da8c4a072cb44342ce8f00e4b0dc684b8e6aebd5d0c131b40ac591f10791e3c1052efe9a5ab531b6163464c9d1e5472fa4ab84a469dcd8685049a2f8d2eb48bcdcae12d76287c26d1ec07cbe89e6570c0e589842685b47616b1a85e9d3133f84c4904d35f00e34fc00cd77668fbfcb2302ed1e6d7a0888dde57fd15c9bc1166c4ee8aea10113ea5fb34361082be549dfe37dfb9c981ebc623306e4fc06b07e55be08ef3e4350d311adea4a48df41e3488a605c752ea4adde2ff5223b8665ec45a3e489a6ab28503757aae30ff63a2022e828942b6242b3992e017956b28ed9d0d4b39c6f81a47f8766bdd82a70efde8841eacd402af74fc0264446e8401a2e7a7448579072c0b9a78d48babea7b3c863927bb12db94ec095f547fd3a38b03d8ce8d7e0e0e1ead217e7bdef9fde4a413159a7cd7abd7ea0467fbaf81c4e51ee8ca2dbee60285627886776c44b3f8291a7de98d883cd389124201105e178a639265ba084022cf91c854f102213b4506c86603dd86aab957a0682c92daf0563b3088cc29414fa9bf7a14a864e0c6385357f2d0ed46919d96065a1702df2e4e01d47c046cf952d65143f86ba0aef27eb9e8686793c45c094183acbedc913a1968e25fbed068700ede9dc1a3a9b5b487d8cdf57fc5ec16291d0b14268663addbc4b0f6165ca234a36ab58caeff114b691d51daa5257482757a17fed2889d98021f5984dd48789746010b58510c20f5ad21183ec880c2ed16f05c6e92d99d1ce28cea6e7d17c73dbbd258321f55b73b359c27358f9d1370e5e9bbc984c029f9bec0eb6824da8485048e8cc523ba3733e92ae0e8de2edcb6753ac70d99f7a62607b89adf38096baca5f9ef072eec77173cd60fc1bcaddbb1a7d509e35e40a8fe9853c2ef9335e3a6f82d0acd1be99d65fe4ddab94cbef07beed57214959e5e409d45907db1e41e19b70181a39db47ec04ad910621eec5b21a741d204330ced02924870b3fd33d7b932d0642eb8fd0fb7a4c13894efcfc27509af63cbc42d2f873e05cbc892203c71fea936e88689505ba2095b88fab946f9863d580ccfbdf60eaed1d3a9e745d14f64d2f70140c5f03783912b038255136790b51c7f8c30eec3d34e5186e8a781efb40b07c2f008a4664083b4512a0f0c35ee1432408c29d4ed468a1027e6f70e5cc5c0cf84a89a5bdf62394361668d71be0ad88c3359d8301a634451f6594a316df09019ccc40e178c0877a29b887cef04f3e8fd5563963374fbbd2d1ee2be0b736b2d1786cf22d15df2935fa3d9247ca5261ab6b0163f98bb92095bb07b11a5e514e6b220a4020ffb29c444249ed4a34018d510dde1303e3f496e1dc1a45536e44e06685ea6319be430b59af71ac0996e5e1ffcac9484f5f256fad103333c9c03a4528509a05365caa2ebbf8991b8d40355c6164305197331ea290aa76f85be5fc47ac95f94c7174746cba691fa550f187dc32ecd072ef8cae6a37f4fda6458ad418d432e33521d9ac408b345189a1afffb7e10a016578b1dbbd71a0108ab8729b4508b257426cb2eb54adf91de4805e4422877bf3d37b62e6e7a6ede14483ccd93e6aa90ca79e4e2cbda77ab09fdc326180db5f70134bbf9cca8acb17cf25af0cca20e7f5cfc0333a40fd35f224fcfd018068f09c0f186e3f638dace22c3b905ae132a50cfe3014f1da3fe111d5db6b487bdd0b85339b3c5bf0d8c26d50d08fd325f9c335127f477f8f5c2f90e5829f80257afb5bab6712ea4f5e68eb25985e33bd3b5cefdb47783ddd23792ed08595c2242aca4b318c7ab0e76b38a0ab2424d242f7aec5bdd0577a359079a987a3ef62a97484309a9530d2e6bb7c107aa4c224f74f19e1f94411c95762fc3e83bb2bc1dbc02548049d84132bc361b4bbd0526277ffe45b29b614b7f728d561da8d1451bd0621bbb116a9d651b80119e7892805edc2566ddc9b39c0f4eb9e5e7e36bf96704342c4429956868d5483c278572493cb19213625a3659ecc67beed48037f1c69972e478d4b33c01cf1ecdbaed8a8c382e468b9da71cda884e2cbb74d252a09d6163920f9527a67455a692c4279cc6b6bf47ed476e18fb8c837406c6147a2cc3ef11c4f8df5a2bf94894348d48ba0c292f6d7f2d685bcb11574bf8eb8c68979b6d4b3b96e66a02b12fbaf22bb4420c9c6cb0b3aaac44c5783394db1a6957e40c12dbc5f40d84efcfd0cfb454faeddb850d4362d2448533a01aedfe119db2ed74000b9669b423d97d0eda1f8931d92dd705ab3d2e0eee1f1968517fed8afe0311e1cb56a827b0ef58e7686c3bbbc1de6ae8c17c742358a08d4fe9dbc51717d2ba469a5f2daf294f9587a5b6d56e5f30b997b4dffd7d9b74d35be0e61589fdcf62162953f2f3337bd750096ee6341088dee9ca57686f67235709ab242c96fd31950481ac9fff1f8776b6d324ca08e2e58404c51a86021c919275821d2047a7257cffb4a833b970db40a9d2e2628db4ca4f3255896316b9b8e0270a9ea9e5ebc820a6a2acf39d06939bc06d3f0e398a8f8a091ad2d55e91c7a15ff98175938627acd7d4896283aca566fa3b9802f8a07752efd9b325b11c15034f82513468b721ab820c7e8dd38fb300669792bcaa0d5deab81812bba86159f6ec4d8fa698b370b09789f0a65e45a3c67f7d4621f06fd66bb736a4561090768cb7870f2caaa89b894f49472f2e87f64a60a4065ce72269ec95c97c779e6181f9b79fb531b6d470ebcac9e710de17f23b1adaf82b64f417dcc50b586b7c1fb0ae6f0362799e6d0129628420746ed575633e40c6366ee91e4e7c552c9ee879e7b005728e08baea89c3e22d98589f154af5812438b5c6a9a1ab1b49c94c24c7c09dd7e33abf66ba09232c0d4a297b2745cbb6653eb8ae10e3cc82d29f23d5efe102b47b9f98ed08579eda5466300dfc0e6e182b575984edbbf064e187bff2f36066048b4b14be6b4952e12300e40a8247d74fb088a10776963ab7060975dd457f35129760d4ed57089b0b655a3f30fff4eb6858623fd1d3394811b150de2a2546df394f94e86317b601b2f43e1c23046b4c79956ac1a3b316ffa774fb8c28aea565b1bf15d1862c76f8437bea1eb1ec0c3b99aeabcc43a1ba938bef6d53b59f777fa88d7dd90aaffc042b7fea915e497c08ce5220ee186d8be22f637cf1b19038d4114877cd51299806fd8496863053b7f9f7cb1230c04c88ec592d8dda71074a445e1bbe0772cb764335edca438e071316d4815ec94f00cea820ff73e0faaffbb3fef27362f616b59a7e2d074fb4106a7f0ddfbd0b4b57e76b5c9a0b067646a62561fc7a418c42fed9db6a2ef6d2e9b75c0034160e908e1b4aa9a99a4b3e9266de833536906bfd9a41320704483b1c85fde4911477db03bed71f288261091f0f4f825777a9dd8a3dd4a660c6705a36e70347a1510276f34e56c9ff43dd994e8335c7937f7959fe30b27a441c3aff99811c9ec31d2ff82653d513d3dac5542c17627ecd810471a758ee8d26736ba1dc736fc23063a4ea8e0ffd3bb4b84e718c78a098aca7fd1744d3000dc5340da97881910270b8e5b8b5a2021624509280b0367360a385542f792b0685a954c6f0b1f7e83eab9b8a5c7931badcd65510794bb2c79ebd0d7f09e38ad690e7b64cf45549d4af163272ff85c57216869b94830ab5185360fa3fa6421abcec69d63b17fa59a40d0be98460dda56f0018a6fe2af2b20138c80fa26dfaf7fd4f08a9977cfe74a4ee4feca7d0b8e8b9584ed5d2989d0a08079d7ecae5053e7b2e0016347f95b5fb2347521277a2def2d8dc8f56b7e4cfba00ed5b8f0a8892c7703657d39c23876956b688a5053c1d629bc8255b5b2bad389f02c40de7e8ad99380b0cef2f979a4355dde700f751ea622fdd8cb7887e8906d3d184d1796b120f6213c4ec1a1b9207e1b46d33c006389ad6140256677a642a6eac6880786fabc2d9abb9fbf12c4d07c19cb4f6aabcbbca3f82ded684cfff5e2108e012c9ca76f88813252821460c64d56a671d94cc1eba2d85089579abfe336cd19e4dc34c342784c044bf40f235358a8b1b78575210bd6246f84297630943546a8b753e80a4aa935d3119eec9f76f706bb7d631d5d373f52fc06960cf6fb580cf9e8fb2f904a0e3a4b821099e97f474fe3c7b069e4445e96225ed4656b4376ac7a4e70ec3b45df605ea053ab4b3a08150a106b4e589ae3327ded12fd0942a3655348bdb1e3ae8d5805ea249b8eea8bc9862dd65f5d034b669924b9594c3fc6d2e1d793b7f5dc1ebc6afed344aa22a3624a7f458a01cb422df9176d353d8c73d78afd5323c40a195424cac41159c1a6d35ff4b1af9761512d21fb1e2c8d178548f4903aa7e61a1b0557fd6fd4afd1e7b37f0ebbe153b653767060eee703cf3bdd14cc9443c4b937f66f1aeedc6817830bcb602d7edf11c59194190404f9510ccbb00d25594208265a400d8621973db5c1c775be6b098cddb0d3adaea4af438d307441265fd8e5d9d17c18808b3ca214fd1e66ac63ca056e443b9ae7bd66c9a74b3a908980c3c9c97856c9f7683c4d789258287ef3f8ca4b2fe86334e280ebd76b83d2cf99849285dbf5542a0fac781489cb7ec60e026069bf6e6fd3d61623c30eb20ca9214fe388167c414cae88379c5458a5b974af4c06c9feb0fc96b131222a697b886d4f6ade308361799c06f49146705895789bddce551eb2d28548322a8e8a64cf8e4baaf4995aad2670e7bb8734e37f749bc0bde9dfc6cd9c59b1292d6b9be23ef46359854b970e172853c699112bd5f54d618f745ca587f36c9448cc022c2b0e8d4fc0dd6bbb2e865db169415943351010c20760c4cd726346c2f34e2cb6086d39489d51585dc12fe4d7bd4c73ff7def7622b97c01d67f8184d521032b0f90a1cd0de3f9bcf0b9b8f7366fd656abd3d0a535543b8e2d5df8d69b4b5f40ff08cd304be0b290b613c208cc5e7ba3a7ed487115cd1fe7f205ca449222f79fcb44e4f619a6c1abb90b849dc58f9d58f69cff9e8de5c34a0e112fc4970913f482de4f320b1bf8618e9c7d9a76801ffffe85939d9d854cfdced2acd3b2099bf9db1d8b8ad8cea3018830e7607710d53a1036a73707fd9cc3aca9abc26e8cee8c554b0ffe17d38155372e6582880e77cef8c1f2ec2581c52b370898ae55f35d352c4791bab39b10ba15ebdcad9af0b1a90a45118a1959ad00bedbb965fed9903aeea1502e460c36a6cf11ed1cb8526798b24029ef46f187eb89b804a65a8774ab1eb9585943b9559f67f40c5a5f2b23a40d78e28ffe1f915ce18e74456f28b2db0fc8cc76d3e8bfd0c2f2c78c38977b9ad5de59f1d58c6357f4341901ce1b849e585c2cddd321ac8359d30e1793e4cd7316e0928fb995ba92f7633b5a406474ebb2209f69537937caa7b5a1b9f539381ffa188cb4221166c02a29562ed45f0cc70546a9cf9f8ed9927a3c6d8af72c61fe2bb32f850ec16521d55dcf61d6381799892c93b163ad1d8dd4e93c8fd3b16fca6851c7a91b70b8f4ca5f01ff4e84e708ef3f9a663118de3e1f25410d319d2f7bb527d7860a6403bee6c38509ae2af33a718b87b3448603249f8c6f8c465287c243e95799b80b813a154973e462c7c6951010856699d45f2f214dd14bf941b2f427ea7c66de05f1af3b34a3d936d38f445acbd21fa46651667420f942496466e2b992a8fff4382ad851507f29b33cb81c00dd8930ab0a700920e477bcc41755b49acd909bd401d531ea0438d6b9b3fd75a1482ff469844f8a231a25f5340ab0f2274eb03b9eff5469ee0989b67c4c2c48afb20c4faac2857a457672d105f2e14f84d41b64b838175c95349671b56319aefeea5c1251deaf97709cd8d804db426b36ff7fa4531c6fea14da5283ffe04eed79eccaf376b7a33372d6b9dd166d888e17be8412cf8d25176610acb84812686f8595f56645e99a6c3d4e5db995db40f5287ba8bcd687a9e7837d9352d5e9639c74de6d6c7b2675c506c120a8979ef213c432ede4894f7b42f52645fc0502157f63cee0a03ce65668b180bbb0e87d096b88240c9bb0368cb8bcde6586b97d9f3adf3cbbd5ef251283f3e5996ffad0fee2562abffcf037b8459e83ded0b02ea7166d86ab93c263bfc3035ba9c6ef39b80a88cc0fd57b1751185077e6c331c98d2e859f9dc268975e6ef085be95865267c6969e9091251cb3b7eb99e837e4a146d8a6a4d55b1083654ee26d414d1289c93390a7677e9473e0d2fe8b8394c61f316e0fe3cf94002fcd03fb85e149e5d3938007bb49e59a2e61ea1a452b97737712aa5b310d878b7c7a05c65a5fe0a62eacb002c134d56c07c94bbc72cd0d2397d5af6f2eda6141379560ef34419caded1f29dc16bc49c8f8329d7ebe16fa570b36d85205fb837e4925289fdaf81a779423f4186f9511e1436b01aa37a1d0a79d73583943d03f9b41ad3449854615fd239aa36533dd7fefd6895a43e2ba6463a859302bb7ced584aca716b87615a335c12bf5eb5b392fef3132827edca9afcb6b8b7a447e29b23796dc1865869fa94c00c3cedaca4fca61be0d11f80b4e69fb18c60744dc80ce21d81f71bde36d8c8264abe7fb9a8c246a2f13632b6e16f4ec9f88aeb5229fe2d3c2aac37c189414ecf394ce8a93cb9d08d5f786921e175a77acd1aeb7d4d6ce764a00bf1a913b4a8718ea9f60ef46d40c6d6c5a777c0fd168dbab414d1e49a5f3f098c1f07b3e5869881e89c3ca7cf42214898df1a98685dc4cf51736281d30248e10f1629d9045a5260cd288632902a0a23f87fe3d01e7dfcd3b66ed233b7d46c16cbd1b64a2558cf63c01f22508e51a79a692d14cbd152457c6277bb9637080ab0b5f61bd6cdcb4389dfd16b94e4069c1da29e2d4c7207624985bdf64a385245d2f4b0ca5fd248d03d0e287640e990478b11dafe40fe68cedeba96059a02e2f3c801bb6553bed766efcbd0c93dfba78a7d0fcef121f7009d76c17b6c58df431e707ec986c0b3196455e6bc29dc223cbbef089ee00fe47856b02a7be61d5cbbf2b3d48ca79e1ca80a15aa546c167916c91325475bc9b91a84c529d092c632d1c1c6b153d8753fd4682cbe1eb77a2f6e689fd33e5dc1a553687256d49d59168d42e0c7a909ea8c07b1f3aa1a750bc24eea019fa8f9d0edfcae1d3ec364af4097d84329dd1dd8ca300c16d284adc258380fe5d953aa1a107586c6eb75c158c2b943a2a2884dcc5b40a5411d5a38b06f0391e91449771d4639e174163a735ce1cf38b157c49f0a00608c3dee168fb7e6bec3a38690ce15f5e462c2c09f5603cccfabe59e2b09822d405c64a2620b838c6b77b70833e30f62dc5b4f5bbe097206ca5ddf58f042fc131ce345e7a61d1cc88950fe6f6c6bae63527cad9a2433c152dd8b3fc48748af64bea4f857703ea5c6874cb87c81a390337cb05dc479a90cb7a4b5ea4eff9ddc42b37c0c4fe94494061649bd463b27816c4d7653ae45ffd05da90fee759c715edecfaee131cc5a6faa54c4a57d679efc586347d3cfb403b43d857e3aaf92a44d4ef6a91415076e1d23e9c72cc13a6709697e2bccf5233088b74a8a85b149cef9c7661c52757ebdc891b59a7d17a87771748903041cbb623fd75940708309e47f34c3fbe0eaab15890beb8db1f4db420c2f0092aa44050fd1997c0c17edc13fb38d7abe0b91d121f65d392a497962013e14c1cad43eb08b194c008493bc5632c9cce1289ebeb7c61e1a0d4f307d087c1d636e664a9e83821e82044cf16e9830220ba8a2bd40962fe2c02db39139437ddeea1c031217eb124091225619cad4fe94e69766787c4fe964310d14684437475bd1ee864db5e810019898ebb1ab0e96d1e9a547d377289918fad44e13ad6aab62e52893220e4434a98038d5f44773d984a7dda62ccb79ba406dc0a4f484eb08b976c390bb8d9262fc0df801da917fc52fe7f605790bc5e6b7bfe5f5626083bab90e3c6806f3ca0d8737fdb6449dd5a0d6270ad67c06d8a111c5e1ac436dfbfecf7ac03aa9152c1a59e5c766fb144dc540841862199505fe792158806d8cee77d4ccc344736848ec12668aa7192a6fc13a6edfb219e74bd8bdb136f2e29c03aba68ce486bb7772df066916f3e5fa8e1cd8309ab5674e95bdf160bfa43bd764cb9b4c812b7e260954493204bdfddb8d3c50b908db076d61ba9480b20c283bbb20050a27fe06f5de828b4056ceb7dd8fe47e29e3e1ff8f9b1dcce04b5fe606e1a493ce6e4d87f1d62d4e80836d3c2bd03d5e34d28e41a506663176fac8f9a4eb2c3141d4c7cf42807afd0b4cc63497be3350e814221d11a759f0a01c5e74938efa63cf0cb79189583b034d908d853895228fe4efb7fee09b9bc3290fb81fdae9c47e077aab6cb410d5a80f7e1f0440dedf7fe21f7872fd1a6fd5beec24bbeca7477c70a4d702e9a7396d1c7d89d316ebe178431cc6730676f2a4a695ff16f0f9597c5d9474ad3467f379ed4a15b6cfa22d29e5b0e83767a56e32cda21437a2c331bb8c1c00279ac087c4984df29f57706f9b532eb8f3b30d5547ce6bb42ca142dd94c370d517b98c22d0d76176bad1e968ea2ff6eed8dae78112ddd364c8ac771a2faa9b28ec9a782a44f38ad13a9ff36eac943af545abdf63cc9fccbea686b3e4e84b0ff206e9867ad19301412ba762bee8168459809a900e7f55037e5f2f7aab3aa3c07ec4ec057aecb458460cb4f77e3abdff53b7eda71a2427fca2c091ceb6ea2a8b9643fa3b69ccffb22ad4ee6d18e3c0541abee1738b1cbe72c24316bddd69bc938d33167979e784a516a9d1a2e8031050b848309839521189b7f21a6150b7e766dda39bc59971e7ee81e48d2ef7201730fb9846b9614cffd9241bc7c95af941b5f733591f73a864d75ba7e3e0ab30a3061a0bc100eb5852b3e20f04cfc1cae996e70b6289af02f47595dd52edadfde0cfb930a011957c1e91baf0320f0acb0b94aa959321ed31bd2a1de5a21f5f3a21aee9a8c2a3596c77cf8db039b753f05bb1a38abca8a3915849192da27f0cb0fe87cf0ba83d505fb9e02a6f61abc772e869ba2c721fd8450f0aca334e218ea6eb78b888c752c863f8e1673f80486c4ac236a5f6e621bb904309dd10bbd854284e0d432d0258d8cfc83be04fe5474261bf22ae278a5582b10b999dd0bb5fdfeb0d4d923ebe70a31c71ff1b1750badd446a674773ffede8f18ea52b4192ab4db515008722797f6246451f22949b30c83f1039b29229bd00a6b218036a43bc67d5a76d41108ad7a803b49c8ee0bacae7b5c54c9fdfb3a0595b3aac5330d776dc1fba436119bf85fb89ee9e2089204304dd0b0e4a398fd25ec00a1c056058c7f58e827f6533fca04415991da8e54d65a04cfee411abb7a336cd6fbeb57ee5b0c91f5377a667ea46d9def6e75b552a596c85ab9f064275ec2b58a82d657ca8d5769b80ad0b7f764f7f88f0c5e1990372a7c23b7260dee390268698637a7acae881e1df74a4591076743246ac4a1a1df668a674c8daa4f4806edb397e386790ea73b9f2c518dee9397b137d6a69ba17855cea88e23bf8e6054649591f84c1a0eabc561796498bdff3f761afdf07bc5b78cd7f0cb5a404b44265dea5c749094654d55b6ab17a60d8acced8b0e673741c07a22963a61202dd88b76dd353010fc97de7ae7ae3292d2fd464264a268a8957daca673c85c58158046759e02ec5ac7746c3bff7c98201b878054beb3235e7f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"41d67f90c27c585b19b39cb53b356e38"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
